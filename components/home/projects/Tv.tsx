/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.18 tv.glb --types 
*/

import * as THREE from 'three'
import React, { useEffect, useRef } from 'react'
import { Image, useGLTF, useTexture } from '@react-three/drei'
import { GLTF } from 'three-stdlib'
import { useLoader, useThree } from '@react-three/fiber'

type GLTFResult = GLTF & {
  nodes: {
    ['10120_LCD_Computer_Monitor_v01_max2011_it2_1']: THREE.Mesh
    ['10120_LCD_Computer_Monitor_v01_max2011_it2_2']: THREE.Mesh
    ['10120_LCD_Computer_Monitor_v01_max2011_it2_3']: THREE.Mesh
  }
  materials: {
    TV: THREE.MeshStandardMaterial
    Backdrop: THREE.MeshStandardMaterial
    Screen: THREE.MeshStandardMaterial
  }
}

type ContextType = Record<string, React.ForwardRefExoticComponent<JSX.IntrinsicElements['mesh']>>

export function TVModel(props: JSX.IntrinsicElements['group'] & { imageURL: string, noRotate?: boolean }) {
  const { nodes, materials } = useGLTF('/tv.glb') as GLTFResult
  const { camera, gl } = useThree();
  const texture = useLoader(THREE.TextureLoader, props.imageURL);
  

  texture.wrapS = texture.wrapT = THREE.ClampToEdgeWrapping;
  texture.flipY = false;
  texture.anisotropy = gl.capabilities.getMaxAnisotropy();

  const screenMaterial = new THREE.MeshStandardMaterial({ map: texture, emissive: 0x000000, emissiveIntensity: 1 });
  screenMaterial.needsUpdate = true;

  const groupRef = useRef<THREE.Group | null>(null);
  

  useEffect(() => {
    if (props.noRotate) return;
    const handleMouseMove = (event: MouseEvent) => {
      if (!groupRef.current) return;

      const { clientX, clientY } = event;
      const { innerWidth, innerHeight } = window;

      const x = (clientX / innerWidth) * 2 - 1;
      const y = -(clientY / innerHeight) * 2 + 1;

      // Convert to 3D space coordinates
      const vector = new THREE.Vector3(x, y, 0.9);
      vector.unproject(camera);

      // Make the group look at the converted vector
      groupRef.current.lookAt(vector);
    };

    window.addEventListener('mousemove', handleMouseMove);

    return () => {
      window.removeEventListener('mousemove', handleMouseMove);
    };
  }, [camera, props.noRotate]);
  return (
    <group ref={groupRef} {...props} dispose={null}>
      <group position={[0, -19.799, 0]}>
        <mesh geometry={nodes['10120_LCD_Computer_Monitor_v01_max2011_it2_1'].geometry} material={materials.TV} />
        <mesh geometry={nodes['10120_LCD_Computer_Monitor_v01_max2011_it2_2'].geometry} material={materials.Backdrop} />
        <mesh geometry={nodes['10120_LCD_Computer_Monitor_v01_max2011_it2_3'].geometry} material={screenMaterial} />
      </group>
    </group>
  )
}

useGLTF.preload('/tv.glb')
